import { basename, join, isAbsolute } from 'node:path'
import fs from 'node:fs'
import fsPromises from 'node:fs/promises'
import { logger, addTypeTemplate, createResolver } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
import { glob } from 'tinyglobby'
import type { IconifyJSON } from '@iconify/types'
import { parseSVGContent, convertParsedSVG } from '@iconify/utils/lib/svg/parse'
import { isPackageExists } from 'local-pkg'
import { watch } from 'chokidar'
import { collectionNames } from './collection-names'
import type { CustomCollection, ServerBundleOptions, RemoteCollection } from './types'

export const isFullCollectionExists = isPackageExists('@iconify/json')

export async function resolveCollection(
  nuxt: Nuxt,
  collection: string | IconifyJSON | CustomCollection | RemoteCollection,
): Promise<string | IconifyJSON | RemoteCollection> {
  if (typeof collection === 'string')
    return collection
  // Custom collection
  if ('dir' in collection) {
    return await loadCustomCollection(collection, nuxt)
  }
  return collection
}

export function setupIconTypes(nuxt: Nuxt) {
  const { resolve } = createResolver(import.meta.url)
  const outputFile = 'types/local-nuxt-icons.d.ts'
  // Get collections from @nuxt/icon config
  const iconConfig = nuxt.options.icon || {}
  const collections = iconConfig.customCollections || []
  // Resolve all icon directories
  const resolvedCollections = collections.map(collection => ({
    dir: resolve(nuxt.options.srcDir, collection.dir),
    prefix: collection.prefix,
  }))
  // Check for missing directories
  const missingDirs = resolvedCollections
    .filter(({ dir }) => !fs.existsSync(dir))
    .map(({ dir }) => dir)
  if (missingDirs.length > 0) {
    console.warn(`Some icon directories do not exist:`, missingDirs)
  }

  // Function to generate types
  const generateLocalSVGTypes = () => {
    // Collect icons from all collections
    const iconNames = resolvedCollections
      .filter(({ dir }) => fs.existsSync(dir))
      .flatMap(({ dir, prefix }) => {
        const iconFiles = fs.readdirSync(dir)
        return iconFiles
          .filter(file => file.endsWith('.svg'))
          .map(file => `'${prefix}:${basename(file, '.svg')}'`)
      })
      .join(' | ')

    addTypeTemplate({
      filename: outputFile,
      write: true,
      getContents: () => `
// Generated by @nuxt/icon
import { DefineComponent } from 'vue'
declare module '@vue/runtime-core' {
  interface GlobalComponents {
    'Icon': DefineComponent<{
      name: ${iconNames}
    }>
  }
}
declare module '#components' {
  interface NuxtIconNames {
${resolvedCollections
  .filter(({ dir }) => fs.existsSync(dir))
  .flatMap(({ dir, prefix }) => {
    const iconFiles = fs.readdirSync(dir)
    return iconFiles
      .filter(file => file.endsWith('.svg'))
      .map(file => `'${prefix}:${basename(file, '.svg')}': true`)
  })
  .join(',\n    ')}
  }
}
export {}
      `.trim(),
    })
  }

  // Generate types during dev server preparation
  nuxt.hook('prepare:types', ({ references }) => {
    generateLocalSVGTypes()
    references.push({ path: outputFile })
  })

  // Generate types on build
  nuxt.hook('build:before', () => {
    generateLocalSVGTypes()
  })

  // Watch for changes in development
  if (nuxt.options.dev) {
    // Watch all icon directories
    const watchers = resolvedCollections
      .filter(({ dir }) => fs.existsSync(dir))
      .map(({ dir }) =>
        watch(dir, {
          ignoreInitial: true,
          ignored: /(^|[/\\])\../,
        }),
      )

    // Set up watchers for all directories
    watchers.forEach((watcher) => {
      watcher.on('all', (event, filepath) => {
        if (filepath.endsWith('.svg')) {
          console.log('Icon files changed, regenerating types...')
          generateLocalSVGTypes()
        }
      })
    })

    // Clean up all watchers on close
    nuxt.hook('close', () => {
      watchers.forEach(watcher => watcher.close())
    })
  }
}

export function getCollectionPath(collection: string) {
  return isFullCollectionExists
    ? `@iconify/json/json/${collection}.json`
    : `@iconify-json/${collection}/icons.json`
}

// https://github.com/iconify/iconify/blob/2274c033b49c01a50dc89b490b89d803d19d95dc/packages/utils/src/icon/name.ts#L15-L18
const validIconNameRE = /^[a-z0-9]+(?:-[a-z0-9]+)*$/

export async function loadCustomCollection(collection: CustomCollection, nuxt: Nuxt): Promise<IconifyJSON> {
  const dir = isAbsolute(collection.dir)
    ? collection.dir
    : join(nuxt.options.rootDir, collection.dir)

  const files = (await glob(['*.svg'], {
    cwd: dir,
    onlyFiles: true,
    expandDirectories: false,
  }))
    .sort()

  const {
    // TODO: next major flip this
    normalizeIconName = true,
  } = collection

  const parsedIcons = await Promise.all(files.map(async (file) => {
    let name = basename(file, '.svg')

    // Currently Iconify only supports kebab-case icon names
    // https://github.com/nuxt/icon/issues/265#issuecomment-2441604639
    // We normalize the icon name to kebab-case and warn user about it
    if (normalizeIconName && !validIconNameRE.test(name)) {
      const normalized = name
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .toLowerCase()
        .replace(/[^a-z0-9-]/g, '-')
        .replace(/-+/g, '-')
      if (normalized !== name)
        logger.warn(`Custom icon \`${name}\` is normalized to \`${normalized}\`, we recommend to change the file name to match the icon name, or pass \`normalizeIconName: false\` to your custom collection options`)
      name = normalized
    }

    let svg = await fsPromises.readFile(join(dir, file), 'utf-8')
    const cleanupIdx = svg.indexOf('<svg')
    if (cleanupIdx > 0)
      svg = svg.slice(cleanupIdx)
    const data = convertParsedSVG(parseSVGContent(svg)!)
    if (!data) {
      logger.error(`Nuxt Icon could not parse the SVG content for icon \`${name}\``)
      return [name, {}]
    }
    if (data.top === 0)
      delete data.top
    if (data.left === 0)
      delete data.left
    return [name, data]
  }))

  const successfulIcons = parsedIcons.filter(([_, data]) => Object.keys(data).length > 0)

  logger.success(`Nuxt Icon loaded local collection \`${collection.prefix}\` with ${successfulIcons.length} icons`)
  const result: IconifyJSON = {
    ...collection,
    icons: Object.fromEntries(successfulIcons),
  }
  // @ts-expect-error remove extra properties
  delete result.dir
  return result
}

export async function discoverInstalledCollections(): Promise<ServerBundleOptions['collections']> {
  const collections = isFullCollectionExists
    ? collectionNames
    : collectionNames.filter(collection => isPackageExists('@iconify-json/' + collection))
  if (isFullCollectionExists)
    logger.success(`Nuxt Icon discovered local-installed ${collections.length} collections (@iconify/json)`)
  else if (collections.length)
    logger.success(`Nuxt Icon discovered local-installed ${collections.length} collections:`, collections.join(', '))

  if (isFullCollectionExists)
    logger.warn('Currently all iconify collections are included in the bundle, which might be inefficient, consider explicit name the collections you use in the `icon.serverBundle.collections` option')

  return collections
}
